/// stratis-fstab-generator
///
/// A systemd generator to enable fstab entries using the /dev/stratis/ symlink paths
/// created by stratisd outside of udev.

const FSTAB_PATH: &str = "/etc/fstab";
const STRATIS_PREFIX: &str = "/dev/stratis";
const KMSG_PATH: &str = "/dev/kmsg";

use std::{
    env,
    error::Error,
    fmt::{self, Display},
    fs::{File, OpenOptions},
    io::{BufReader, BufRead, Write},
    path::{Path, PathBuf},
};

use inotify::{Inotify, WatchMask};

#[derive(Debug)]
struct GenError(String);

impl Error for GenError {}

impl Display for GenError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

fn get_output_dir() -> Result<PathBuf, Box<dyn Error>> {
    // Get highest priority output directory.
    let mut args = env::args();
    match args.nth(1) {
        Some(ref od) => {
            let output_dir = PathBuf::from(od);
            if !output_dir.exists() {
                return Err(Box::new(GenError(format!(
                    "Output directory {} for .device files does not exist",
                    od,
                ))))
            }
            Ok(output_dir)
        },
        None => Err(Box::new(GenError(
            "Required output directory argument not provided".to_string()
        ))),
    }
}

/// Returns a list of device paths and mountpoint from fstab.
fn read_fstab() -> Result<Vec<(PathBuf, PathBuf)>, Box<dyn Error>> {
    let buf_reader = BufReader::new(File::open(FSTAB_PATH)?);
    
    let mut mount_targets = Vec::new();
    for line_result in buf_reader.lines() {
        let line = line_result?;
        let mut columns = line.split_whitespace();
        let (mount_target_verbatim, mount_target) = match columns.next() {
            Some(s) => {
                if s.starts_with(STRATIS_PREFIX) {
                    (s.clone(), PathBuf::from(s).canonicalize()?)
                } else {
                    continue;
                }
            },
            None => continue,
        };
        let mount_point = match columns.next() {
            Some(s) => PathBuf::from(s),
            None => return Err(Box::new(GenError(
                format!("No mount point was found for fstab entry {}", mount_target_verbatim)
            ))),
        };
        mount_targets.push((mount_target, mount_point));
    }
    Ok(mount_targets)
}

fn modify_fstab_entires_for_stratis(
    dir: &Path,
    fstab_entires: Vec<(PathBuf, PathBuf)>
) -> Result<(), Box<dyn Error>> {
    for (mt, mp) in fstab_entires {
        let mut mnt_file_path = PathBuf::new();
        mnt_file_path.push(dir);
        let mangled_file_name = mp.display()
            .to_string()
            .split('/')
            .filter(|s| *s != "")
            .map(|s| {
                if s.contains("-") {
                    s.replace('-', "\\x2d")
                } else {
                    s.to_string()
                }
            })
            .collect::<Vec<_>>()
            .join("-");
        mnt_file_path.push(mangled_file_name);
        if !mnt_file_path.exists() {
            std::thread::sleep(Duration::new(0, 50));
        }
    }
}

fn generate_device_files(dir: &Path, fstab_entries: Vec<(PathBuf, PathBuf)>) -> Result<(), Box<dyn Error>> {
    for (mt, _mp) in fstab_entries.iter() {
        let filename = format!(
            "{}.device",
            mt.display()
                .to_string()
                .split('/')
                .filter(|s| *s != "")
                .map(|s| {
                    if s.contains("-") {
                        s.replace('-', "\\x2d")
                    } else {
                        s.to_string()
                    }
                })
                .collect::<Vec<_>>()
                .join("-")
        );
        let mut path = PathBuf::new();
        path.push(dir);
        path.push(filename);
        let mut file = OpenOptions::new()
            .create(true)
            .write(true)
            .open(path)?;
        file.write_all(format!(
            "# Automatically generated by stratis-fstab-generator\n\
            \n\
            [Unit]\n\
            Description={}\n\
            AssertPathExists={}\n\
            Requires=stratisd.service\n",
            mt.display(),
            mt.display()
        ).as_bytes())?;
        file.flush()?;
    }
    Ok(())
}

fn error_to_kmsg(error: Box<dyn Error>) -> Result<(), Box<dyn Error>> {
    // Syslog error code
    let priority = 3;
    // Syslog daemon facility
    let facility = 3;

    let msg = format!(
        "<{}>stratis-fstab-generator: {}",
        facility << 3 | priority,
        error,
    );

    let mut file = OpenOptions::new().write(true).open(KMSG_PATH)?;
    file.write_all(msg.as_bytes())?;

    Ok(())
}

fn handle_error_to_kmsg(error: Box<dyn Error>) -> ! {
    if let Err(e) = error_to_kmsg(error) {
        println!("{}", e);
    }
    std::process::exit(1);
}

fn main() {
    let highest_prior_output_dir = match get_output_dir() {
        Ok(od) => od,
        Err(e) => handle_error_to_kmsg(e),
    };

    let stratis_fstab_entries = match read_fstab() {
        Ok(fse) => fse,
        Err(e) => handle_error_to_kmsg(e),
    };

    match generate_device_files(&highest_prior_output_dir, stratis_fstab_entries) {
        Ok(_) => (),
        Err(e) => handle_error_to_kmsg(e),
    };
}
